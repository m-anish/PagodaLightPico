<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Build config.json ‚Ä¢ PagodaLightPico</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, 'Noto Sans', 'Liberation Sans', sans-serif; margin: 20px; background: #f5f5f5; }
    .container { max-width: 920px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    h1 { color: #2c3e50; text-align: center; }
    fieldset { border: 1px solid #e5e7eb; border-radius: 10px; margin: 16px 0; padding: 12px; background: #fafafa; }
    fieldset.meta { border-left: 4px solid #60a5fa; }
    fieldset.wifi { border-left: 4px solid #34d399; }
    fieldset.tz { border-left: 4px solid #f59e0b; }
    fieldset.system { border-left: 4px solid #a78bfa; }
    fieldset.notif { border-left: 4px solid #f87171; }
    fieldset.pwm { border-left: 4px solid #22d3ee; }
    label { display: block; margin: 6px 0; }
    input, select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 6px; }
    .row { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
    .actions { display: flex; gap: 12px; flex-wrap: wrap; }
    button, a.button { padding: 10px 14px; border: 1px solid #999; border-radius: 8px; background: #fff; cursor: pointer; text-decoration: none; color: #222; }
    pre { background: #0b1020; color: #d5e6ff; padding: 12px; border-radius: 8px; overflow: auto; max-height: 420px; }
    .tip { font-size: 12px; color: #666; }
    legend { font-weight: 600; color: #374151; }
    .emoji { font-size: 1.1em; margin-right: 6px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Build config.json</h1>

    <form id="cfgForm" oninput="render()" onchange="render()">
      <fieldset class="meta">
        <legend><span class="emoji">üß©</span>Meta</legend>
        <label>Version (semver)
          <input id="version" type="text" value="0.4.0" placeholder="0.4.0" required />
        </label>
        <label>Hostname
          <input id="hostname" type="text" value="PagodaLightPico" />
        </label>
      </fieldset>

      <fieldset class="wifi">
        <legend><span class="emoji">üì∂</span>WiFi</legend>
        <div class="row">
          <label>SSID
            <input id="ssid" type="text" placeholder="your_wifi_ssid_here" />
          </label>
          <label>Password
            <input id="password" type="password" placeholder="your_wifi_password_here" />
          </label>
        </div>
      </fieldset>

      <fieldset class="tz">
        <legend><span class="emoji">üåç</span>Timezone</legend>
        <div class="row">
          <label>Choose your timezone
            <select id="tz_select"></select>
          </label>
          <div style="display:none">
            <label>Name
              <input id="tz_name" type="text" value="IST" />
            </label>
            <label>UTC Offset (hours)
              <input id="tz_offset" type="number" step="0.25" value="5.5" />
            </label>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Hardware</legend>
        <div class="row">
          <label>RTC SDA pin
            <input id="rtc_sda" type="number" value="20" />
          </label>
          <label>RTC SCL pin
            <input id="rtc_scl" type="number" value="21" />
          </label>
        </div>
        <label>PWM frequency (Hz)
          <input id="pwm_freq" type="number" value="1000" />
        </label>
      </fieldset>

      <fieldset class="system">
        <legend><span class="emoji">üõ†Ô∏è</span>System</legend>
        <div class="row">
          <label>Log level
            <select id="log_level">
              <option>DEBUG</option>
              <option selected>INFO</option>
              <option>WARNING</option>
              <option>ERROR</option>
            </select>
          </label>
          <label>Update interval (s)
            <input id="update_interval" type="number" value="120" />
          </label>
        </div>
        <div class="row">
          <label>Server idle sleep (ms)
            <input id="server_idle_sleep_ms" type="number" value="300" />
          </label>
          <label>Client read sleep (ms)
            <input id="client_read_sleep_ms" type="number" value="50" />
          </label>
        </div>
        <label>Network check interval (s)
          <input id="network_check_interval" type="number" value="120" />
        </label>
        <div class="row">
          <label>RAM telemetry enabled
            <select id="ram_telemetry_enabled"><option value="true">true</option><option value="false" selected>false</option></select>
          </label>
          <label>RAM telemetry interval (s)
            <input id="ram_telemetry_interval" type="number" value="300" />
          </label>
        </div>
        <label>Web title
          <input id="web_title" type="text" value="PagodaLightPico" />
        </label>
      </fieldset>

      <fieldset class="notif">
        <legend><span class="emoji">üîî</span>Notifications (MQTT)</legend>
        <div class="row">
          <label>Enabled
            <select id="notif_enabled"><option value="true">true</option><option value="false" selected>false</option></select>
          </label>
          <label>Broker
            <input id="mqtt_broker" type="text" value="broker.hivemq.com" />
          </label>
        </div>
        <div class="row">
          <label>Port
            <input id="mqtt_port" type="number" value="1883" />
          </label>
          <label>Topic
            <input id="mqtt_topic" type="text" value="PagodaLightPico/notifications" />
          </label>
        </div>
        <div class="row">
          <label>Client ID
            <input id="mqtt_client_id" type="text" value="PagodaLightPico" />
          </label>
          <label>Notify on window change
            <select id="notify_window"><option>true</option><option selected>false</option></select>
          </label>
        </div>
        <label>Notify on errors
          <select id="notify_errors"><option>true</option><option selected>false</option></select>
        </label>
      </fieldset>

      <fieldset class="pwm">
        <legend><span class="emoji">üéöÔ∏è</span>PWM Pins</legend>
        <div class="tip">Add up to 5 pins. For each pin, add 1‚Äì5 time windows. Duty cycle is 0‚Äì100.</div>
        <div class="actions" style="margin:6px 0 12px;">
          <button type="button" onclick="addPin()">Add Pin</button>
        </div>
        <div id="pinsContainer"></div>
      </fieldset>
    </form>

    <div class="actions">
      <button onclick="downloadJSON()">Download config.json</button>
      <a class="button" href="./index.html">Back to Home</a>
    </div>

    <h2>Preview</h2>
    <pre id="preview"></pre>
  </div>

  <script>
    // --- PWM Pins dynamic state ---
    const MAX_PINS = 5;
    const MAX_WINDOWS = 5;
    const MIN_WINDOWS = 1;
    const pins = [];

    function newPin() {
      const usedGpios = new Set(pins.map(p => p.gpio_pin));
      let gpio = 16;
      for (let i=0;i<=22;i++){ if(!usedGpios.has(i)){ gpio=i; break; } }
      return { gpio_pin: gpio, name: `Pin ${gpio}`, enabled: false, windows: [ newWindow() ] };
    }

    // --- Timezone selector ---
    const TZ_OPTIONS = [
      { name: 'UTC', offset: 0, label: 'UTC (¬±0:00)' },
      { name: 'IST', offset: 5.5, label: 'India Standard Time (IST) UTC+5:30' },
      { name: 'PST', offset: -8, label: 'Pacific Standard Time (PST) UTC-8:00' },
      { name: 'PDT', offset: -7, label: 'Pacific Daylight Time (PDT) UTC-7:00' },
      { name: 'EST', offset: -5, label: 'Eastern Standard Time (EST) UTC-5:00' },
      { name: 'EDT', offset: -4, label: 'Eastern Daylight Time (EDT) UTC-4:00' },
      { name: 'CET', offset: 1, label: 'Central European Time (CET) UTC+1:00' },
      { name: 'CEST', offset: 2, label: 'Central European Summer Time (CEST) UTC+2:00' },
      { name: 'JST', offset: 9, label: 'Japan Standard Time (JST) UTC+9:00' },
      { name: 'AEST', offset: 10, label: 'Australian Eastern Standard (AEST) UTC+10:00' },
      { name: 'AEDT', offset: 11, label: 'Australian Eastern Daylight (AEDT) UTC+11:00' }
    ];

    function populateTimezoneSelect(){
      const sel = document.getElementById('tz_select');
      sel.innerHTML = TZ_OPTIONS.map(tz => `<option value="${tz.name}" data-offset="${tz.offset}">${tz.label}</option>`).join('');
      // default IST if present
      const def = TZ_OPTIONS.findIndex(z => z.name === 'IST');
      sel.selectedIndex = def >= 0 ? def : 0;
      applyTimezoneFromSelect();
      sel.addEventListener('change', applyTimezoneFromSelect);
    }

    function applyTimezoneFromSelect(){
      const sel = document.getElementById('tz_select');
      const name = sel.value;
      const offset = parseFloat(sel.options[sel.selectedIndex].getAttribute('data-offset'));
      document.getElementById('tz_name').value = name;
      document.getElementById('tz_offset').value = String(offset);
      render();
    }
    function newWindow(name){ return { name: name || '', start: 'sunrise', end: 'sunset', duty_cycle: 0 }; }

    function addPin(){ if (pins.length < MAX_PINS) { pins.push(newPin()); renderPinsUI(); render(); } }
    function removePin(idx){ pins.splice(idx,1); renderPinsUI(); render(); }
    function addWindowToPin(idx){ if (pins[idx].windows.length < MAX_WINDOWS){ pins[idx].windows.push(newWindow()); renderPinsUI(); render(); } }
    function removeWindowFromPin(pidx, widx){ if (pins[pidx].windows.length > MIN_WINDOWS){ pins[pidx].windows.splice(widx,1); renderPinsUI(); render(); } }

    function gpioSelect(current){
      const opts = Array.from({length:23}, (_,i)=>`<option value="${i}" ${i===current? 'selected':''}>${i}</option>`).join('');
      return `<select data-type="gpio">${opts}</select>`;
    }
    function boolSelect(val){ return `<select data-type="enabled"><option value="true" ${val? 'selected':''}>true</option><option value="false" ${!val? 'selected':''}>false</option></select>`; }
    function timeSelector(val, which){
      const isKeyword = (val === 'sunrise' || val === 'sunset');
      const keyword = isKeyword ? val : 'custom';
      const time = isKeyword ? '' : (val || '18:00');
      const disp = keyword==='custom' ? '' : 'display:none;';
      const dis = keyword==='custom' ? '' : 'disabled';
      return `
        <div class="row">
          <label style="grid-column: span 1;">${which} type
            <select data-type="${which}-type">
              <option value="sunrise" ${keyword==='sunrise'?'selected':''}>sunrise</option>
              <option value="sunset" ${keyword==='sunset'?'selected':''}>sunset</option>
              <option value="custom" ${keyword==='custom'?'selected':''}>custom</option>
            </select>
          </label>
          <label data-time-label="${which}" style="grid-column: span 1; ${disp}">${which} time
            <input type="time" value="${time}" data-type="${which}-time" ${dis} />
          </label>
        </div>`;
    }

    function renderPinsUI(){
      const container = document.getElementById('pinsContainer');
      container.innerHTML = '';
      pins.forEach((p, idx) => {
        const card = document.createElement('div');
        card.style.border = '1px solid #eee';
        card.style.borderRadius = '8px';
        card.style.padding = '12px';
        card.style.marginBottom = '12px';
        card.innerHTML = `
          <div class="row">
            <label>GPIO ${gpioSelect(p.gpio_pin)}</label>
            <label>Name <input type="text" value="${p.name}" data-type="name" /></label>
          </div>
          <div class="row">
            <label>Enabled ${boolSelect(p.enabled)}</label>
            <div style="display:flex; align-items:flex-end; gap:8px;">
              <button type="button" ${pins.length<=1?'disabled':''} data-action="remove-pin">Remove Pin</button>
              <button type="button" ${p.windows.length>=MAX_WINDOWS?'disabled':''} data-action="add-window">Add Window</button>
            </div>
          </div>
          <div class="tip">Windows (min ${MIN_WINDOWS}, max ${MAX_WINDOWS}). Note: device requires at least a 'day' window and 2‚Äì5 windows when the pin is enabled.</div>
          <div class="windows"></div>
        `;

        const winWrap = card.querySelector('.windows');
        p.windows.forEach((w, widx) => {
          const block = document.createElement('div');
          block.style.border = '1px dashed #ddd';
          block.style.borderRadius = '6px';
          block.style.padding = '8px';
          block.style.margin = '8px 0';
          block.innerHTML = `
            <div class="row">
              <label>Window title
                <input type="text" value="${w.name ?? (widx===0?'day':`w${widx+1}`)}" data-type="win-name" />
              </label>
            </div>
            ${timeSelector(w.start,'start')}
            ${timeSelector(w.end,'end')}
            <div class="row">
              <label>Duty cycle (0-100)
                <input type="range" min="0" max="100" value="${w.duty_cycle}" data-type="duty" />
                <span data-type="duty-val">${w.duty_cycle}</span>
              </label>
              <div style="display:flex; align-items:flex-end;">
                <button type="button" ${p.windows.length<=MIN_WINDOWS?'disabled':''} data-action="remove-window" data-widx="${widx}">Remove Window</button>
              </div>
            </div>`;
          // attach events for this window
          block.addEventListener('input', (e) => {
            const t = e.target.getAttribute('data-type');
            if (t === 'win-name') { w.name = e.target.value; }
            if (t === 'start-type') { w.start = e.target.value === 'custom' ? (w.start.match(/^\d{2}:\d{2}$/) ? w.start : '18:00') : e.target.value; }
            if (t === 'start-time') { w.start = e.target.value.trim(); }
            if (t === 'end-type') { w.end = e.target.value === 'custom' ? (w.end.match(/^\d{2}:\d{2}$/) ? w.end : '22:00') : e.target.value; }
            if (t === 'end-time') { w.end = e.target.value.trim(); }
            if (t === 'start-type' || t === 'end-type') {
              // toggle visibility of time inputs for the specific which
              const which = t.startsWith('start') ? 'start' : 'end';
              const lbl = block.querySelector(`label[data-time-label="${which}"]`);
              if (lbl) {
                const isCustom = e.target.value === 'custom';
                const input = lbl.querySelector('input');
                if (isCustom) { lbl.style.display=''; input.removeAttribute('disabled'); }
                else { lbl.style.display='none'; input.setAttribute('disabled',''); }
              }
            }
            if (t === 'duty') { let v = parseInt(e.target.value||'0'); if (isNaN(v)) v=0; v=Math.max(0,Math.min(100,v)); w.duty_cycle = v; const span = block.querySelector('span[data-type="duty-val"]'); if (span) span.textContent = v; }
            render();
          });
          block.addEventListener('click', (e) => {
            if (e.target.getAttribute('data-action') === 'remove-window') { removeWindowFromPin(idx, parseInt(e.target.getAttribute('data-widx'))); }
          });
          winWrap.appendChild(block);
        });

        card.addEventListener('input', (e) => {
          const t = e.target.getAttribute('data-type');
          if (t === 'name') p.name = e.target.value;
          if (t === 'gpio') p.gpio_pin = parseInt(e.target.value);
          if (t === 'enabled') p.enabled = (e.target.value === 'true');
          render();
        });
        card.addEventListener('click', (e) => {
          const act = e.target.getAttribute('data-action');
          if (act === 'remove-pin') removePin(idx);
          if (act === 'add-window') addWindowToPin(idx);
        });

        container.appendChild(card);
      });
    }

    function validateTimeString(s){
      return s === 'sunrise' || s === 'sunset' || /^\d{2}:\d{2}$/.test(s);
    }

    function windowsFromObject(time_windows){
      if (!time_windows || typeof time_windows !== 'object') return [ newWindow() ];
      const arr = [];
      if (time_windows.day) {
        const w = time_windows.day;
        arr.push({
          name: 'day',
          start: validateTimeString(w.start) ? w.start : 'sunrise',
          end: validateTimeString(w.end) ? w.end : 'sunset',
          duty_cycle: Math.max(0, Math.min(100, parseInt(w.duty_cycle||0)))
        });
      }
      Object.keys(time_windows)
        .filter(k => k !== 'day' && !k.startsWith('_'))
        .sort()
        .forEach(k => {
          const w = time_windows[k] || {};
          arr.push({
            name: k,
            start: validateTimeString(w.start) ? w.start : 'sunset',
            end: validateTimeString(w.end) ? w.end : 'sunrise',
            duty_cycle: Math.max(0, Math.min(100, parseInt(w.duty_cycle||0)))
          });
        });
      if (arr.length === 0) arr.push(newWindow());
      return arr.slice(0, MAX_WINDOWS);
    }

    async function loadSamplePins(){
      try {
        const resp = await fetch('./config.json.sample', { cache: 'no-store' });
        if (!resp.ok) throw new Error('fetch failed');
        const sample = await resp.json();
        const pwm = sample && sample.pwm_pins || {};
        const list = Object.values(pwm)
          .filter(x => x && typeof x === 'object')
          .map(x => ({
            gpio_pin: parseInt(x.gpio_pin),
            name: (x.name || `Pin ${x.gpio_pin}`),
            enabled: !!x.enabled,
            windows: windowsFromObject(x.time_windows || {})
          }))
          .filter(x => !isNaN(x.gpio_pin));
        // Sort by gpio_pin ascending to have deterministic order
        list.sort((a,b)=>a.gpio_pin-b.gpio_pin);
        pins.splice(0, pins.length, ...list.slice(0, MAX_PINS));
      } catch (e) {
        // ignore; fallback will add a default pin
      }
    }

    // --- existing builder ---
    function buildConfig(){
      const getBool = (el) => (document.getElementById(el).value === 'true');
      const cfg = {
        version: document.getElementById('version').value.trim() || '0.4.0',
        wifi: {
          ssid: document.getElementById('ssid').value,
          password: document.getElementById('password').value
        },
        hostname: document.getElementById('hostname').value || 'PagodaLightPico',
        timezone: {
          name: document.getElementById('tz_name').value || 'IST',
          offset: parseFloat(document.getElementById('tz_offset').value || '0')
        },
        hardware: {
          rtc_i2c_sda_pin: parseInt(document.getElementById('rtc_sda').value||'20'),
          rtc_i2c_scl_pin: parseInt(document.getElementById('rtc_scl').value||'21'),
          pwm_frequency: parseInt(document.getElementById('pwm_freq').value||'1000')
        },
        system: {
          log_level: document.getElementById('log_level').value,
          update_interval: parseInt(document.getElementById('update_interval').value||'120'),
          server_idle_sleep_ms: parseInt(document.getElementById('server_idle_sleep_ms').value||'300'),
          client_read_sleep_ms: parseInt(document.getElementById('client_read_sleep_ms').value||'50'),
          network_check_interval: parseInt(document.getElementById('network_check_interval').value||'120'),
          ram_telemetry_enabled: getBool('ram_telemetry_enabled'),
          ram_telemetry_interval: parseInt(document.getElementById('ram_telemetry_interval').value||'300'),
          web_title: document.getElementById('web_title').value || 'PagodaLightPico'
        },
        notifications: {
          enabled: getBool('notif_enabled'),
          mqtt_broker: document.getElementById('mqtt_broker').value || 'broker.hivemq.com',
          mqtt_port: parseInt(document.getElementById('mqtt_port').value||'1883'),
          mqtt_topic: document.getElementById('mqtt_topic').value || 'PagodaLightPico/notifications',
          mqtt_client_id: document.getElementById('mqtt_client_id').value || 'PagodaLightPico',
          notify_on_window_change: document.getElementById('notify_window').value === 'true',
          notify_on_errors: document.getElementById('notify_errors').value === 'true'
        },
        pwm_pins: {}
      };

      // Build pwm_pins from dynamic pins[] state
      pins.forEach((p, idx) => {
        const key = `pin_${p.gpio_pin}`;
        const tw = {};
        p.windows.forEach((w, widx) => {
          // sanitize times and determine key name
          const s = validateTimeString(w.start) ? w.start : 'sunset';
          const e = validateTimeString(w.end) ? w.end : 'sunrise';
          const provided = (w.name || '').trim();
          const keyName = (widx === 0 && provided === '') ? 'day' : (provided || `w${widx+1}`);
          tw[keyName] = { start: s, end: e, duty_cycle: Math.max(0, Math.min(100, parseInt(w.duty_cycle||0))) };
        });
        cfg.pwm_pins[key] = {
          name: p.name || key,
          gpio_pin: p.gpio_pin,
          enabled: !!p.enabled,
          time_windows: tw
        };
      });

      return cfg;
    }

    function render(){
      const cfg = buildConfig();
      document.getElementById('preview').textContent = JSON.stringify(cfg, null, 2);
    }

    function downloadJSON(){
      const blob = new Blob([JSON.stringify(buildConfig(), null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'config.json';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // initialize from sample, fallback to one default pin
    (async function init(){
      await loadSamplePins();
      if (pins.length === 0) { pins.push(newPin()); }
      populateTimezoneSelect();
      renderPinsUI();
      render();
    })();
  </script>
</body>
</html>
