<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Build config.json ‚Ä¢ PagodaLightPico</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, 'Noto Sans', 'Liberation Sans', sans-serif; margin: 20px; background: #f5f5f5; }
    .container { max-width: 920px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    h1 { color: #2c3e50; text-align: center; }
    fieldset { border: 1px solid #e5e7eb; border-radius: 10px; margin: 16px 0; padding: 12px; background: #fafafa; }
    fieldset.meta { border-left: 4px solid #60a5fa; }
    fieldset.wifi { border-left: 4px solid #34d399; }
    fieldset.tz { border-left: 4px solid #f59e0b; }
    fieldset.hardware { border-left: 4px solid #10b981; }
    fieldset.system { border-left: 4px solid #a78bfa; }
    fieldset.notif { border-left: 4px solid #f87171; }
    fieldset.pwm { border-left: 4px solid #22d3ee; }
    label { display: block; margin: 6px 0; }
    input, select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 6px; max-width: 100%; }
    .row { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); column-gap: 12px; row-gap: 12px; align-items: start; }
    @media (max-width: 640px){ .row { grid-template-columns: 1fr; } }
    .actions { display: flex; gap: 12px; flex-wrap: wrap; }
    button, a.button, label.button { padding: 10px 14px; border: 1px solid #999; border-radius: 8px; background: #fff; cursor: pointer; text-decoration: none; color: #222; display:inline-flex; align-items:center; gap:6px; }
    pre { background: #0b1020; color: #d5e6ff; padding: 12px; border-radius: 8px; overflow: auto; max-height: 420px; }
    .tip { font-size: 12px; color: #666; }
    legend { font-weight: 600; color: #374151; }
    .emoji { font-size: 1.1em; margin-right: 6px; }
    /* collapsible */
    fieldset.collapsed > :not(legend) { display: none; }
    .legend-row { display:flex; align-items:center; gap:8px; }
    .collapse-toggle { border:none; background:none; cursor:pointer; font-size:14px; }
    /* PWM visuals */
    .pin-card { background:#f8fafc; }
    .gpio-head { font-size:12px; color:#374151; margin:2px 0 6px; display:flex; align-items:center; gap:6px; }
    .window-block { background:#e8f2ff; border-left:6px solid #3b82f6; border:1px solid #dbeafe; }
    .window-head { font-size: 12px; color: #374151; margin-bottom: 6px; display:flex; align-items:center; gap:6px; }
    .sub-toggle { border:none; background:none; cursor:pointer; font-size:12px; padding:0 4px; }
    .window-block.collapsed > .window-body { display:none; }
    .pin-card .gpio-body.collapsed { display:none; }
    /* validation */
    .validation { margin-top:6px; font-size:12px; }
    .validation.ok { color:#065f46; }
    .validation.err { color:#b91c1c; }
    /* password reveal */
    .password-wrapper { position: relative; }
    .reveal-btn { position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: transparent; border: none; cursor: pointer; font-size: 14px; }
  </style>
</head>
<body>
  <div class="container">
    <h1><span class="emoji">‚öôÔ∏è</span>Build config.json</h1>

    <form id="cfgForm" oninput="render()" onchange="render()">
      <fieldset class="meta">
        <legend><span class="legend-row"><button type="button" class="collapse-toggle" aria-label="toggle">‚ñº</button><span class="emoji">üß©</span>Meta</span></legend>
        <label>Version (semver)
          <input id="version" type="text" value="0.4.0" placeholder="0.4.0" required />
        </label>
        <label>Hostname
          <input id="hostname" type="text" value="PagodaLightPico" />
        </label>
      </fieldset>

      <fieldset class="wifi">
        <legend><span class="legend-row"><button type="button" class="collapse-toggle" aria-label="toggle">‚ñº</button><span class="emoji">üì∂</span>WiFi</span></legend>
        <div class="row">
          <label>SSID
            <input id="ssid" type="text" placeholder="your_wifi_ssid_here" />
          </label>
          <label>Password
            <span class="password-wrapper">
              <input id="password" type="password" placeholder="your_wifi_password_here" />
              <button id="password_toggle" type="button" class="reveal-btn" aria-label="Show password" onclick="togglePassword()">üôà</button>
            </span>
          </label>
        </div>
      </fieldset>

      <fieldset class="tz">
        <legend><span class="legend-row"><button type="button" class="collapse-toggle" aria-label="toggle">‚ñº</button><span class="emoji">üåç</span>Timezone</span></legend>
        <div class="row">
          <label>Search timezone
            <input id="tz_search" type="text" placeholder="Search (e.g., India, PST, +5:30, Tokyo)" />
          </label>
          <label>Select timezone
            <select id="tz_select" size="6" style="height:auto;"></select>
          </label>
          <div style="display:none">
            <label>Name
              <input id="tz_name" type="text" value="IST" />
            </label>
            <label>UTC Offset (hours)
              <input id="tz_offset" type="number" step="0.25" value="5.5" />
            </label>
          </div>
        </div>
      </fieldset>

      <fieldset class="hardware">
        <legend><span class="legend-row"><button type="button" class="collapse-toggle" aria-label="toggle">‚ñº</button><span class="emoji">üß∞</span>Hardware</span></legend>
        <div class="row">
          <label>RTC SDA pin
            <select id="rtc_sda"></select>
          </label>
          <label>RTC SCL pin
            <select id="rtc_scl"></select>
          </label>
        </div>
        <label>PWM frequency (Hz)
          <input id="pwm_freq" type="number" value="1000" />
        </label>
      </fieldset>

      <fieldset class="system">
        <legend><span class="legend-row"><button type="button" class="collapse-toggle" aria-label="toggle">‚ñº</button><span class="emoji">üõ†Ô∏è</span>System</span></legend>
        <div class="row">
          <label>Log level
            <select id="log_level">
              <option>DEBUG</option>
              <option selected>INFO</option>
              <option>WARNING</option>
              <option>ERROR</option>
            </select>
          </label>
          <label>Update interval (s)
            <input id="update_interval" type="number" value="120" />
          </label>
        </div>
        <div class="row">
          <label>Server idle sleep (ms)
            <input id="server_idle_sleep_ms" type="number" value="300" />
          </label>
          <label>Client read sleep (ms)
            <input id="client_read_sleep_ms" type="number" value="50" />
          </label>
        </div>
        <label>Network check interval (s)
          <input id="network_check_interval" type="number" value="120" />
        </label>
        <div class="row">
          <label>RAM telemetry enabled
            <select id="ram_telemetry_enabled"><option value="true">true</option><option value="false" selected>false</option></select>
          </label>
          <label>RAM telemetry interval (s)
            <input id="ram_telemetry_interval" type="number" value="300" />
          </label>
        </div>
        <label>Web title
          <input id="web_title" type="text" value="PagodaLightPico" />
        </label>
      </fieldset>

      <fieldset class="notif">
        <legend><span class="legend-row"><button type="button" class="collapse-toggle" aria-label="toggle">‚ñº</button><span class="emoji">üîî</span>Notifications (MQTT)</span></legend>
        <div class="row">
          <label>Enabled
            <select id="notif_enabled"><option value="true">true</option><option value="false" selected>false</option></select>
          </label>
          <label>Broker
            <input id="mqtt_broker" type="text" value="broker.hivemq.com" />
          </label>
        </div>
        <div class="row">
          <label>Port
            <input id="mqtt_port" type="number" value="1883" />
          </label>
          <label>Topic
            <input id="mqtt_topic" type="text" value="PagodaLightPico/notifications" />
          </label>
        </div>
        <div class="row">
          <label>Client ID
            <input id="mqtt_client_id" type="text" value="PagodaLightPico" />
          </label>
          <label>Notify on window change
            <select id="notify_window"><option>true</option><option selected>false</option></select>
          </label>
        </div>
        <label>Notify on errors
          <select id="notify_errors"><option>true</option><option selected>false</option></select>
        </label>
      </fieldset>

      <fieldset class="pwm">
        <legend><span class="legend-row"><button type="button" class="collapse-toggle" aria-label="toggle">‚ñº</button><span class="emoji">üéöÔ∏è</span>PWM Pins</span></legend>
        <div class="tip">Add up to 5 pins. For each pin, add 1‚Äì5 time windows. Duty cycle is 0‚Äì100.</div>
        <div class="actions" style="margin:6px 0 12px;">
          <button type="button" onclick="addPin()">Add Pin</button>
        </div>
        <div id="pinsContainer"></div>
      </fieldset>
    </form>

    <div id="global_validation" class="tip"></div>

    <div class="actions">
      <button id="download_btn" type="button" onclick="downloadJSON()">Download config.json</button>
      <button id="upload_btn" type="button">Upload and prefill</button>
      <input id="upload_config" type="file" accept="application/json,.json" style="position:absolute; width:1px; height:1px; padding:0; margin:-1px; border:0; clip:rect(0,0,0,0); overflow:hidden;" />
      <a class="button" href="./index.html">Back to Home</a>
    </div>
    <div id="upload_msg" class="tip"></div>

    <h2>Preview</h2>
    <pre id="preview"></pre>
  </div>

  <script>
    // --- PWM Pins dynamic state ---
    const MAX_PINS = 5;
    const MAX_WINDOWS = 5;
    const MIN_WINDOWS = 1;
    const pins = [];

    function newPin() {
      const usedGpios = new Set(pins.map(p => p.gpio_pin));
      let gpio = 16;
      for (let i=0;i<=22;i++){ if(!usedGpios.has(i)){ gpio=i; break; } }
      return { gpio_pin: gpio, name: `Pin ${gpio}`, enabled: false, windows: [ newWindow() ] };
    }

    // Password reveal toggle
    function togglePassword(){
      const input = document.getElementById('password');
      const btn = document.getElementById('password_toggle');
      const willShow = input.type === 'password';
      input.type = willShow ? 'text' : 'password';
      // update icon and aria
      btn.textContent = willShow ? 'üëÅÔ∏è' : 'üôà';
      btn.setAttribute('aria-label', willShow ? 'Hide password' : 'Show password');
    }

    // Collapsible sections
    function setupCollapsibles(){
      document.querySelectorAll('fieldset').forEach(fs => {
        const btn = fs.querySelector('.collapse-toggle');
        if (!btn) return;
        btn.addEventListener('click', () => {
          fs.classList.toggle('collapsed');
          btn.textContent = fs.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
        });
      });
    }

    // --- Timezone selector ---
    const TZ_OPTIONS = [
      { name: 'UTC', offset: 0, label: 'UTC (¬±0:00)' },
      { name: 'GMT', offset: 0, label: 'Greenwich Mean Time (GMT) UTC¬±0:00' },
      { name: 'WET', offset: 0, label: 'Western European Time (WET) UTC¬±0:00' },
      { name: 'CET', offset: 1, label: 'Central European Time (CET) UTC+1:00' },
      { name: 'CEST', offset: 2, label: 'Central European Summer (CEST) UTC+2:00' },
      { name: 'EET', offset: 2, label: 'Eastern European Time (EET) UTC+2:00' },
      { name: 'EEST', offset: 3, label: 'Eastern European Summer (EEST) UTC+3:00' },
      { name: 'MSK', offset: 3, label: 'Moscow Time (MSK) UTC+3:00' },
      { name: 'GST', offset: 4, label: 'Gulf Standard Time (GST) UTC+4:00' },
      { name: 'PKT', offset: 5, label: 'Pakistan Standard Time (PKT) UTC+5:00' },
      { name: 'IST', offset: 5.5, label: 'India Standard Time (IST) UTC+5:30' },
      { name: 'NPT', offset: 5.75, label: 'Nepal Time (NPT) UTC+5:45' },
      { name: 'BST_BD', offset: 6, label: 'Bangladesh Standard (BST) UTC+6:00' },
      { name: 'MMT', offset: 6.5, label: 'Myanmar Time (MMT) UTC+6:30' },
      { name: 'ICT', offset: 7, label: 'Indochina Time (ICT) UTC+7:00' },
      { name: 'CST_China', offset: 8, label: 'China Standard Time (CST) UTC+8:00' },
      { name: 'AWST', offset: 8, label: 'Australian Western (AWST) UTC+8:00' },
      { name: 'JST', offset: 9, label: 'Japan Standard Time (JST) UTC+9:00' },
      { name: 'KST', offset: 9, label: 'Korea Standard Time (KST) UTC+9:00' },
      { name: 'ACST', offset: 9.5, label: 'Australian Central (ACST) UTC+9:30' },
      { name: 'AEST', offset: 10, label: 'Australian Eastern (AEST) UTC+10:00' },
      { name: 'AEDT', offset: 11, label: 'Australian Eastern Daylight (AEDT) UTC+11:00' },
      { name: 'NZST', offset: 12, label: 'New Zealand Standard (NZST) UTC+12:00' },
      { name: 'NZDT', offset: 13, label: 'New Zealand Daylight (NZDT) UTC+13:00' },
      { name: 'AST', offset: -4, label: 'Atlantic Standard Time (AST) UTC-4:00' },
      { name: 'ADT', offset: -3, label: 'Atlantic Daylight Time (ADT) UTC-3:00' },
      { name: 'BRST', offset: -2, label: 'Brazil Summer (BRST) UTC-2:00' },
      { name: 'BRT', offset: -3, label: 'Bras√≠lia Time (BRT) UTC-3:00' },
      { name: 'ART', offset: -3, label: 'Argentina Time (ART) UTC-3:00' },
      { name: 'EST', offset: -5, label: 'Eastern Standard (EST) UTC-5:00' },
      { name: 'EDT', offset: -4, label: 'Eastern Daylight (EDT) UTC-4:00' },
      { name: 'CST', offset: -6, label: 'Central Standard (CST) UTC-6:00' },
      { name: 'CDT', offset: -5, label: 'Central Daylight (CDT) UTC-5:00' },
      { name: 'MST', offset: -7, label: 'Mountain Standard (MST) UTC-7:00' },
      { name: 'MDT', offset: -6, label: 'Mountain Daylight (MDT) UTC-6:00' },
      { name: 'PST', offset: -8, label: 'Pacific Standard (PST) UTC-8:00' },
      { name: 'PDT', offset: -7, label: 'Pacific Daylight (PDT) UTC-7:00' },
      { name: 'AKST', offset: -9, label: 'Alaska Standard (AKST) UTC-9:00' },
      { name: 'AKDT', offset: -8, label: 'Alaska Daylight (AKDT) UTC-8:00' },
      { name: 'HST', offset: -10, label: 'Hawaii Standard (HST) UTC-10:00' }
    ];

    function populateTimezoneSelect(list){
      const sel = document.getElementById('tz_select');
      const items = list || TZ_OPTIONS;
      sel.innerHTML = items.map(tz => `<option value="${tz.name}" data-offset="${tz.offset}">${tz.label}</option>`).join('');
      if (!list) {
        const def = TZ_OPTIONS.findIndex(z => z.name === 'IST');
        sel.selectedIndex = def >= 0 ? def : 0;
        applyTimezoneFromSelect();
      }
    }

    function applyTimezoneFromSelect(){
      const sel = document.getElementById('tz_select');
      const name = sel.value;
      const offset = parseFloat(sel.options[sel.selectedIndex].getAttribute('data-offset'));
      document.getElementById('tz_name').value = name;
      document.getElementById('tz_offset').value = String(offset);
      render();
    }

    function filterTimezones(){
      const q = (document.getElementById('tz_search').value || '').toLowerCase();
      if (!q) { populateTimezoneSelect(); applyTimezoneFromSelect(); return; }
      const filtered = TZ_OPTIONS.filter(tz =>
        tz.name.toLowerCase().includes(q) ||
        tz.label.toLowerCase().includes(q) ||
        String(tz.offset).includes(q)
      );
      populateTimezoneSelect(filtered);
      // keep first match selected if any
      if (filtered.length) { document.getElementById('tz_select').selectedIndex = 0; applyTimezoneFromSelect(); }
    }

    function setupTimezoneSearch(){
      const s = document.getElementById('tz_search');
      s.addEventListener('input', filterTimezones);
    }
    function newWindow(name){ return { name: name || '', start: 'sunrise', end: 'sunset', duty_cycle: 0 }; }

    function addPin(){ if (pins.length < MAX_PINS) { pins.push(newPin()); renderPinsUI(); render(); } }
    function removePin(idx){ pins.splice(idx,1); renderPinsUI(); render(); }
    function addWindowToPin(idx){ if (pins[idx].windows.length < MAX_WINDOWS){ pins[idx].windows.push(newWindow()); renderPinsUI(); render(); } }
    function removeWindowFromPin(pidx, widx){ if (pins[pidx].windows.length > MIN_WINDOWS){ pins[pidx].windows.splice(widx,1); renderPinsUI(); render(); } }

    // Populate RTC SDA/SCL selects with valid GPIOs (0‚Äì22) and set defaults
    const GOOD_GPIO = Array.from({length:23}, (_,i)=>i);
    function populateHardwareGpioSelects(){
      const fill = (sel, defVal) => {
        if (!sel) return;
        if (!sel.options.length){ sel.innerHTML = GOOD_GPIO.map(i=>`<option value="${i}">${i}</option>`).join(''); }
        const v = String(parseInt(defVal));
        if (v !== 'NaN'){ sel.value = v; if (sel.value !== v) sel.selectedIndex = 0; }
      };
      fill(document.getElementById('rtc_sda'), (document.getElementById('rtc_sda').value || 20));
      fill(document.getElementById('rtc_scl'), (document.getElementById('rtc_scl').value || 21));
    }

    // Helpers to read RTC pins and compute cross-pin validation
    function readRTC(){
      const sdaEl = document.getElementById('rtc_sda');
      const sclEl = document.getElementById('rtc_scl');
      const sda = parseInt(sdaEl && sdaEl.value || '20');
      const scl = parseInt(sclEl && sclEl.value || '21');
      return { sda, scl };
    }

    function computeGPIOValidation(){
      const errs = [];
      const { sda, scl } = readRTC();
      // Basic validity
      if (!GOOD_GPIO.includes(sda)) errs.push(`RTC SDA (${sda}) is not a valid GPIO`);
      if (!GOOD_GPIO.includes(scl)) errs.push(`RTC SCL (${scl}) is not a valid GPIO`);

      // Build usage map
      const usage = new Map();
      const addUse = (pin, role) => {
        if (!Number.isFinite(pin)) return;
        if (!usage.has(pin)) usage.set(pin, []);
        usage.get(pin).push(role);
      };
      addUse(sda, 'RTC SDA');
      addUse(scl, 'RTC SCL');
      pins.forEach((p, idx) => addUse(p.gpio_pin, `PWM pin ${idx+1}`));

      // Detect clashes (same GPIO used by multiple roles)
      usage.forEach((roles, pin) => {
        if (roles.length > 1) errs.push(`GPIO ${pin} is used by: ${roles.join(', ')}`);
      });

      return errs;
    }

    function gpioSelect(current){
      const opts = Array.from({length:23}, (_,i)=>`<option value="${i}" ${i===current? 'selected':''}>${i}</option>`).join('');
      return `<select data-type="gpio">${opts}</select>`;
    }
    function boolSelect(val){ return `<select data-type="enabled"><option value="true" ${val? 'selected':''}>true</option><option value="false" ${!val? 'selected':''}>false</option></select>`; }
    function timeSelector(val, which){
      const isKeyword = (val === 'sunrise' || val === 'sunset');
      const keyword = isKeyword ? val : 'custom';
      const time = isKeyword ? '' : (val || '18:00');
      const disp = keyword==='custom' ? '' : 'display:none;';
      const dis = keyword==='custom' ? '' : 'disabled';
      return `
        <div class="row">
          <label style="grid-column: span 1;">${which} type
            <select data-type="${which}-type">
              <option value="sunrise" ${keyword==='sunrise'?'selected':''}>sunrise</option>
              <option value="sunset" ${keyword==='sunset'?'selected':''}>sunset</option>
              <option value="custom" ${keyword==='custom'?'selected':''}>custom</option>
            </select>
          </label>
          <label data-time-label="${which}" style="grid-column: span 1; ${disp}">${which} time
            <input type="time" value="${time}" data-type="${which}-time" ${dis} />
          </label>
        </div>`;
    }

    function renderPinsUI(){
      const container = document.getElementById('pinsContainer');
      container.innerHTML = '';
      pins.forEach((p, idx) => {
        const card = document.createElement('div');
        card.className = 'pin-card';
        card.style.border = '1px solid #e5e7eb';
        card.style.borderRadius = '8px';
        card.style.padding = '12px';
        card.style.marginBottom = '12px';
        card.innerHTML = `
          <div class="gpio-head"><button type="button" class="sub-toggle" data-action="toggle-gpio">‚ñº</button> GPIO Pin ${p.gpio_pin}</div>
          <div class="gpio-body">
            <div class="row">
              <label>GPIO ${gpioSelect(p.gpio_pin)}</label>
              <label>Name <input type="text" value="${p.name}" data-type="name" /></label>
            </div>
            <div class="row">
              <label>Enabled ${boolSelect(p.enabled)}</label>
              <div style="display:flex; align-items:flex-end; gap:8px;">
                <button type="button" ${pins.length<=1?'disabled':''} data-action="remove-pin">Remove Pin</button>
                <button type="button" ${p.windows.length>=MAX_WINDOWS?'disabled':''} data-action="add-window">Add Window</button>
              </div>
            </div>
            <div class="tip">Windows (min ${MIN_WINDOWS}, max ${MAX_WINDOWS}). Note: device requires at least a 'day' window and 2‚Äì5 windows when the pin is enabled.</div>
            <div class="windows"></div>
            <div class="validation" data-role="validation"></div>
          </div>
        `;

        const winWrap = card.querySelector('.windows');
        p.windows.forEach((w, widx) => {
          const block = document.createElement('div');
          block.className = 'window-block';
          block.style.border = '1px dashed #ddd';
          block.style.borderRadius = '6px';
          block.style.padding = '8px';
          block.style.margin = '8px 0';
          block.style.background = '#e8f2ff';
          block.innerHTML = `
            <div class="window-head"><button type="button" class="sub-toggle" data-action="toggle-window" data-widx="${widx}">‚ñº</button> ‚è±Ô∏è Window ${widx+1}</div>
            <div class="window-body">
            <div class="row">
              <label>Window title
                <input type="text" value="${w.name ?? (widx===0?'day':`w${widx+1}`)}" data-type="win-name" />
              </label>
            </div>
            ${timeSelector(w.start,'start')}
            ${timeSelector(w.end,'end')}
            <div class="row">
              <label>Duty cycle (0-100)
                <input type="range" min="0" max="100" value="${w.duty_cycle}" data-type="duty" />
                <span data-type="duty-val">${w.duty_cycle}</span>
              </label>
              <div style="display:flex; align-items:flex-end;">
                <button type="button" ${p.windows.length<=MIN_WINDOWS?'disabled':''} data-action="remove-window" data-widx="${widx}">Remove Window</button>
              </div>
            </div>
            </div>`;
          // attach events for this window
          block.addEventListener('input', (e) => {
            const t = e.target.getAttribute('data-type');
            if (t === 'win-name') { w.name = e.target.value; }
            if (t === 'start-type') { w.start = e.target.value === 'custom' ? (w.start.match(/^\d{2}:\d{2}$/) ? w.start : '18:00') : e.target.value; }
            if (t === 'start-time') { w.start = e.target.value.trim(); }
            if (t === 'end-type') { w.end = e.target.value === 'custom' ? (w.end.match(/^\d{2}:\d{2}$/) ? w.end : '22:00') : e.target.value; }
            if (t === 'end-time') { w.end = e.target.value.trim(); }
            if (t === 'start-type' || t === 'end-type') {
              // toggle visibility of time inputs for the specific which
              const which = t.startsWith('start') ? 'start' : 'end';
              const lbl = block.querySelector(`label[data-time-label="${which}"]`);
              if (lbl) {
                const isCustom = e.target.value === 'custom';
                const input = lbl.querySelector('input');
                if (isCustom) { lbl.style.display=''; input.removeAttribute('disabled'); }
                else { lbl.style.display='none'; input.setAttribute('disabled',''); }
              }
            }
            if (t === 'duty') { let v = parseInt(e.target.value||'0'); if (isNaN(v)) v=0; v=Math.max(0,Math.min(100,v)); w.duty_cycle = v; const span = block.querySelector('span[data-type="duty-val"]'); if (span) span.textContent = v; }
            // Update validation for this pin without full re-render
            const vd = computePinValidation(p);
            const vEl = card.querySelector('[data-role="validation"]');
            if (vEl) { vEl.textContent = vd.msg; vEl.className = `validation ${vd.ok ? 'ok' : 'err'}`; }
            render();
          });
          block.addEventListener('click', (e) => {
            if (e.target.getAttribute('data-action') === 'remove-window') { removeWindowFromPin(idx, parseInt(e.target.getAttribute('data-widx'))); }
          });
          winWrap.appendChild(block);
        });

        card.addEventListener('input', (e) => {
          const t = e.target.getAttribute('data-type');
          if (t === 'name') p.name = e.target.value;
          if (t === 'gpio') p.gpio_pin = parseInt(e.target.value);
          if (t === 'enabled') p.enabled = (e.target.value === 'true');
          render();
        });
        card.addEventListener('click', (e) => {
          const act = e.target.getAttribute('data-action');
          if (act === 'remove-pin') removePin(idx);
          if (act === 'add-window') addWindowToPin(idx);
          if (act === 'toggle-gpio') {
            const body = card.querySelector('.gpio-body');
            e.target.textContent = body.classList.contains('collapsed') ? '‚ñº' : '‚ñ∂';
            body.classList.toggle('collapsed');
          }
          if (act === 'toggle-window') {
            const wTarget = e.target.closest('.window-block');
            const nowCollapsed = !wTarget.classList.contains('collapsed');
            e.target.textContent = nowCollapsed ? '‚ñ∂' : '‚ñº';
            wTarget.classList.toggle('collapsed');
          }
        });

        // Set initial validation message for this pin
        const vd = computePinValidation(p);
        const vEl = card.querySelector('[data-role="validation"]');
        if (vEl) { vEl.textContent = vd.msg; vEl.className = `validation ${vd.ok ? 'ok' : 'err'}`; }
        container.appendChild(card);
      });
    }

    function validateTimeString(s){
      return s === 'sunrise' || s === 'sunset' || /^\d{2}:\d{2}$/.test(s);
    }

    // Compute continuity + wrap-around validation for a pin's windows
    function computePinValidation(p){
      const wins = (p && p.windows) ? p.windows : [];
      if (!wins.length) return { ok: false, msg: 'No windows configured' };
      for (let i=0; i<wins.length-1; i++){
        const endPrev = String(wins[i].end||'').trim();
        const startNext = String(wins[i+1].start||'').trim();
        if (endPrev !== startNext){
          return { ok: false, msg: `Window ${i+1} end must equal Window ${i+2} start` };
        }
      }
      const firstStart = String(wins[0].start||'').trim();
      const lastEnd = String(wins[wins.length-1].end||'').trim();
      if (firstStart !== lastEnd){
        return { ok: false, msg: `First start (${firstStart}) must equal last end (${lastEnd}) for 24h coverage` };
      }
      return { ok: true, msg: 'Windows cover 24h continuously' };
    }

    // (deprecated) earlier global validation kept for context; superseded by enhanced version below
    function updateGlobalValidation_old(){ /* superseded by enhanced version */ }

    function windowsFromObject(time_windows){
      if (!time_windows || typeof time_windows !== 'object') return [ newWindow() ];
      const arr = [];
      if (time_windows.day) {
        const w = time_windows.day;
        arr.push({
          name: 'day',
          start: validateTimeString(w.start) ? w.start : 'sunrise',
          end: validateTimeString(w.end) ? w.end : 'sunset',
          duty_cycle: Math.max(0, Math.min(100, parseInt(w.duty_cycle||0)))
        });
      }
      Object.keys(time_windows)
        .filter(k => k !== 'day' && !k.startsWith('_'))
        .sort()
        .forEach(k => {
          const w = time_windows[k] || {};
          arr.push({
            name: k,
            start: validateTimeString(w.start) ? w.start : 'sunset',
            end: validateTimeString(w.end) ? w.end : 'sunrise',
            duty_cycle: Math.max(0, Math.min(100, parseInt(w.duty_cycle||0)))
          });
        });
      if (arr.length === 0) arr.push(newWindow());
      return arr.slice(0, MAX_WINDOWS);
    }

    async function loadSamplePins(){
      try {
        const resp = await fetch('./config.json.sample', { cache: 'no-store' });
        if (!resp.ok) throw new Error('fetch failed');
        const sample = await resp.json();
        const pwm = sample && sample.pwm_pins || {};
        const list = Object.values(pwm)
          .filter(x => x && typeof x === 'object')
          .map(x => ({
            gpio_pin: parseInt(x.gpio_pin),
            name: (x.name || `Pin ${x.gpio_pin}`),
            enabled: !!x.enabled,
            windows: windowsFromObject(x.time_windows || {})
          }))
          .filter(x => !isNaN(x.gpio_pin));
        // Sort by gpio_pin ascending to have deterministic order
        list.sort((a,b)=>a.gpio_pin-b.gpio_pin);
        pins.splice(0, pins.length, ...list.slice(0, MAX_PINS));
      } catch (e) {
        // ignore; fallback will add a default pin
      }
    }

    // --- existing builder ---
    function buildConfig(){
      const getBool = (el) => (document.getElementById(el).value === 'true');
      const cfg = {
        version: document.getElementById('version').value.trim() || '0.4.0',
        wifi: {
          ssid: document.getElementById('ssid').value,
          password: document.getElementById('password').value
        },
        hostname: document.getElementById('hostname').value || 'PagodaLightPico',
        timezone: {
          name: document.getElementById('tz_name').value || 'IST',
          offset: parseFloat(document.getElementById('tz_offset').value || '0')
        },
        hardware: {
          rtc_i2c_sda_pin: parseInt(document.getElementById('rtc_sda').value||'20'),
          rtc_i2c_scl_pin: parseInt(document.getElementById('rtc_scl').value||'21'),
          pwm_frequency: parseInt(document.getElementById('pwm_freq').value||'1000')
        },
        system: {
          log_level: document.getElementById('log_level').value,
          update_interval: parseInt(document.getElementById('update_interval').value||'120'),
          server_idle_sleep_ms: parseInt(document.getElementById('server_idle_sleep_ms').value||'300'),
          client_read_sleep_ms: parseInt(document.getElementById('client_read_sleep_ms').value||'50'),
          network_check_interval: parseInt(document.getElementById('network_check_interval').value||'120'),
          ram_telemetry_enabled: getBool('ram_telemetry_enabled'),
          ram_telemetry_interval: parseInt(document.getElementById('ram_telemetry_interval').value||'300'),
          web_title: document.getElementById('web_title').value || 'PagodaLightPico'
        },
        notifications: {
          enabled: getBool('notif_enabled'),
          mqtt_broker: document.getElementById('mqtt_broker').value || 'broker.hivemq.com',
          mqtt_port: parseInt(document.getElementById('mqtt_port').value||'1883'),
          mqtt_topic: document.getElementById('mqtt_topic').value || 'PagodaLightPico/notifications',
          mqtt_client_id: document.getElementById('mqtt_client_id').value || 'PagodaLightPico',
          notify_on_window_change: document.getElementById('notify_window').value === 'true',
          notify_on_errors: document.getElementById('notify_errors').value === 'true'
        },
        pwm_pins: {}
      };

      // Build pwm_pins from dynamic pins[] state
      pins.forEach((p, idx) => {
        const key = `pin_${p.gpio_pin}`;
        const tw = {};
        p.windows.forEach((w, widx) => {
          // sanitize times and determine key name
          const s = validateTimeString(w.start) ? w.start : 'sunset';
          const e = validateTimeString(w.end) ? w.end : 'sunrise';
          const provided = (w.name || '').trim();
          const keyName = (widx === 0 && provided === '') ? 'day' : (provided || `w${widx+1}`);
          tw[keyName] = { start: s, end: e, duty_cycle: Math.max(0, Math.min(100, parseInt(w.duty_cycle||0))) };
        });
        cfg.pwm_pins[key] = {
          name: p.name || key,
          gpio_pin: p.gpio_pin,
          enabled: !!p.enabled,
          time_windows: tw
        };
      });

      return cfg;
    }

    function render(){
      const cfg = buildConfig();
      document.getElementById('preview').textContent = JSON.stringify(cfg, null, 2);
      // Update global validation (window continuity + GPIO clashes)
      if (typeof updateGlobalValidation === 'function') updateGlobalValidation();
    }

    function downloadJSON(){
      const blob = new Blob([JSON.stringify(buildConfig(), null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'config.json';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // --- Upload + Prefill helpers ---
    let sampleMajorMinor = null;

    function majorMinor(v){
      if (!v || typeof v !== 'string') return null;
      const parts = v.split('.');
      if (parts.length < 2) return null;
      return `${parts[0]}.${parts[1]}`;
    }

    async function fetchSampleVersion(){
      try {
        const resp = await fetch('./config.json.sample', { cache: 'no-store' });
        if (!resp.ok) return;
        const sample = await resp.json();
        sampleMajorMinor = majorMinor(sample.version || '');
      } catch {}
    }

    // Aggregate validation and reflect near the Download button
    function updateGlobalValidation(){
      const errs = [];
      // Per-pin window validations
      pins.forEach((p) => { const vd = computePinValidation(p); if (!vd.ok) errs.push(`GPIO ${p.gpio_pin}: ${vd.msg}`); });
      // Cross-pin GPIO clashes
      errs.push(...computeGPIOValidation());

      const out = document.getElementById('global_validation');
      const btn = document.getElementById('download_btn');
      if (out){
        if (errs.length){
          out.innerHTML = errs.map(e=>`‚ùå ${e}`).join('<br>');
          out.style.color = '#b91c1c';
        } else {
          out.textContent = '';
          out.style.color = '';
        }
      }
      if (btn){
        if (errs.length){
          btn.setAttribute('disabled','');
          btn.style.opacity = '0.5';
          btn.style.cursor = 'not-allowed';
        } else {
          btn.removeAttribute('disabled');
          btn.style.opacity = '';
          btn.style.cursor = '';
        }
      }
    }

    function setMsg(html, isError){
      const el = document.getElementById('upload_msg');
      if (!el) return;
      el.innerHTML = html || '';
      el.style.color = isError ? '#b91c1c' : '#374151';
    }

    function applyConfigToForm(cfg){
      try {
        if (cfg.version) document.getElementById('version').value = cfg.version;
        if (cfg.hostname) document.getElementById('hostname').value = cfg.hostname;

        if (cfg.wifi){
          if (cfg.wifi.ssid !== undefined) document.getElementById('ssid').value = cfg.wifi.ssid;
          if (cfg.wifi.password !== undefined) document.getElementById('password').value = cfg.wifi.password;
        }

        if (cfg.timezone){
          if (cfg.timezone.name !== undefined) document.getElementById('tz_name').value = cfg.timezone.name;
          if (cfg.timezone.offset !== undefined) document.getElementById('tz_offset').value = String(cfg.timezone.offset);
          const sel = document.getElementById('tz_select');
          if (sel){
            const idx = Array.from(sel.options).findIndex(o => o.value === (cfg.timezone.name||''));
            if (idx >= 0) sel.selectedIndex = idx;
          }
        }

        if (cfg.hardware){
          // Ensure dropdowns are populated, then set values from config
          populateHardwareGpioSelects();
          if (cfg.hardware.rtc_sda !== undefined) document.getElementById('rtc_sda').value = String(cfg.hardware.rtc_sda);
          if (cfg.hardware.rtc_i2c_sda_pin !== undefined) document.getElementById('rtc_sda').value = String(cfg.hardware.rtc_i2c_sda_pin);
          if (cfg.hardware.rtc_scl !== undefined) document.getElementById('rtc_scl').value = String(cfg.hardware.rtc_scl);
          if (cfg.hardware.rtc_i2c_scl_pin !== undefined) document.getElementById('rtc_scl').value = String(cfg.hardware.rtc_i2c_scl_pin);
          if (cfg.hardware.pwm_freq !== undefined) document.getElementById('pwm_freq').value = cfg.hardware.pwm_freq;
          if (cfg.hardware.pwm_frequency !== undefined) document.getElementById('pwm_freq').value = cfg.hardware.pwm_frequency;
        }

        if (cfg.system){
          if (cfg.system.log_level) document.getElementById('log_level').value = cfg.system.log_level;
          if (cfg.system.update_interval !== undefined) document.getElementById('update_interval').value = cfg.system.update_interval;
          if (cfg.system.server_idle_sleep_ms !== undefined) document.getElementById('server_idle_sleep_ms').value = cfg.system.server_idle_sleep_ms;
          if (cfg.system.client_read_sleep_ms !== undefined) document.getElementById('client_read_sleep_ms').value = cfg.system.client_read_sleep_ms;
          if (cfg.system.network_check_interval !== undefined) document.getElementById('network_check_interval').value = cfg.system.network_check_interval;
          if (cfg.system.ram_telemetry_enabled !== undefined) document.getElementById('ram_telemetry_enabled').value = String(!!cfg.system.ram_telemetry_enabled);
          if (cfg.system.ram_telemetry_interval !== undefined) document.getElementById('ram_telemetry_interval').value = cfg.system.ram_telemetry_interval;
          if (cfg.system.web_title) document.getElementById('web_title').value = cfg.system.web_title;
        }

        if (cfg.notifications){
          if (cfg.notifications.enabled !== undefined) document.getElementById('notif_enabled').value = String(!!cfg.notifications.enabled);
          if (cfg.notifications.broker !== undefined) document.getElementById('mqtt_broker').value = cfg.notifications.broker;
          if (cfg.notifications.mqtt_broker !== undefined) document.getElementById('mqtt_broker').value = cfg.notifications.mqtt_broker;
          if (cfg.notifications.port !== undefined) document.getElementById('mqtt_port').value = cfg.notifications.port;
          if (cfg.notifications.mqtt_port !== undefined) document.getElementById('mqtt_port').value = cfg.notifications.mqtt_port;
          if (cfg.notifications.username !== undefined) document.getElementById('mqtt_username').value = cfg.notifications.username;
          if (cfg.notifications.password !== undefined) document.getElementById('mqtt_password').value = cfg.notifications.password;
          if (cfg.notifications.topic !== undefined) document.getElementById('mqtt_topic').value = cfg.notifications.topic;
          if (cfg.notifications.mqtt_topic !== undefined) document.getElementById('mqtt_topic').value = cfg.notifications.mqtt_topic;
          if (cfg.notifications.client_id !== undefined) document.getElementById('mqtt_client_id').value = cfg.notifications.client_id;
          if (cfg.notifications.mqtt_client_id !== undefined) document.getElementById('mqtt_client_id').value = cfg.notifications.mqtt_client_id;
          if (cfg.notifications.notify_window !== undefined) document.getElementById('notify_window').value = String(!!cfg.notifications.notify_window);
          if (cfg.notifications.notify_on_window_change !== undefined) document.getElementById('notify_window').value = String(!!cfg.notifications.notify_on_window_change);
          if (cfg.notifications.notify_errors !== undefined) document.getElementById('notify_errors').value = String(!!cfg.notifications.notify_errors);
          if (cfg.notifications.notify_on_errors !== undefined) document.getElementById('notify_errors').value = String(!!cfg.notifications.notify_on_errors);
        }

        if (cfg.pwm_pins && typeof cfg.pwm_pins === 'object'){
          const list = Object.values(cfg.pwm_pins)
            .filter(x => x && typeof x === 'object')
            .map(x => ({
              gpio_pin: parseInt(x.gpio_pin),
              name: (x.name || `Pin ${x.gpio_pin}`),
              enabled: !!x.enabled,
              windows: windowsFromObject(x.time_windows || {})
            }))
            .filter(x => !isNaN(x.gpio_pin));
          list.sort((a,b)=>a.gpio_pin-b.gpio_pin);
          pins.splice(0, pins.length, ...list.slice(0, MAX_PINS));
          renderPinsUI();
        }

        render();
        setMsg('Prefilled from uploaded file.');
      } catch (e) {
        setMsg('Failed to apply uploaded config.', true);
      }
    }

    function setupUpload(){
      const inp = document.getElementById('upload_config');
      const btn = document.getElementById('upload_btn');
      if (!inp) return;
      if (btn) btn.addEventListener('click', () => inp.click());
      inp.addEventListener('change', async (ev) => {
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        try {
          const text = await f.text();
          const cfg = JSON.parse(text);
          const upMM = majorMinor(cfg.version || '');
          if (sampleMajorMinor && upMM && sampleMajorMinor !== upMM){
            setMsg(`Version mismatch: expected ${sampleMajorMinor}.x but got ${cfg.version}. Upload aborted.`, true);
            return;
          }
          applyConfigToForm(cfg);
        } catch (e) {
          setMsg('Invalid JSON file.', true);
        } finally {
          ev.target.value = '';
        }
      });
    }

    // initialize from sample, fallback to one default pin
    (async function init(){
      await fetchSampleVersion();
      await loadSamplePins();
      if (pins.length === 0) { pins.push(newPin()); }
      populateTimezoneSelect();
      setupTimezoneSearch();
      populateHardwareGpioSelects();
      setupCollapsibles();
      setupUpload();
      renderPinsUI();
      render();
    })();
  </script>
</body>
</html>
